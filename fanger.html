
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Fanger Shoebox MRTCalc</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
        color: purple;
      }

      a {
        color: red;
      }
    </style>
  </head>
  <body>

    <script type="text/javascript" src="js/libs/three.js/build/three.min.js"></script>
    <script type="text/javascript" src="js/libs/three.js/src/extras/cameras/CombinedCamera.js"></script>
    <script type="text/javascript" src="js/libs/three.js/examples/js/controls/OrbitControls.js"></script>
    <script type="text/javascript" src="js/libs/stats.min.js"></script>
    <script type="text/javascript" src="js/libs/dat-gui/build/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/libs/underscore.min.js"></script>
    <script type="text/javascript" src="js/mrt.js"></script>
    
    <script>

      var container, stats;
      var camera, scene, renderer, raycaster, projector, INTERSECTED, directionalLight;
      var surfaces = [];
      var mouse = new THREE.Vector2();

      mrt.occupant = {
          'position': {'x': 1, 'y': 1},
          'azimuth': Math.PI / 3, 
          'posture': 'seated',
      };

      mrt.room = {
          'length': 20.0, 
          'width': 15.0, 
          'height': 2.6,
      }

      params = {
          'opacity': 0, 
          'wall 1': {
            'temperature': 26.0,
            'emissivity': 0.9
          },
          'wall 2': {
            'temperature': 36.0,
            'emissivity': 0.9
          },
          'wall 3': {
            'temperature': 41.0,
            'emissivity': 0.9
          },
          'wall 4': {
            'temperature': 26.0,
            'emissivity': 0.9
          },
          'ceiling': {
            'temperature': 26.0,
            'emissivity': 0.9
          },
          'floor': {
            'temperature': 26.0,
            'emissivity': 0.9
          },
          'autocalculate': true,
          'calculate now': function(){
            calculate_all();
          }
      };

      function set_wall_properties(){
        mrt.walls = [
            {
                'name': 'wall1', 
                'temperature': params['wall 1'].temperature,
                'emissivity': params['wall 1'].emissivity,
                'plane': 'xz', 
                'u': mrt.room.width,
                'v': mrt.room.height,
                'offset': {'x': 0, 'y': 0, 'z': 0},
                'subsurfaces': [],
            },
            {
                'name': 'wall2', 
                'temperature': params['wall 2'].temperature,
                'emissivity': params['wall 2'].emissivity,
                'plane': 'yz', 
                'u': mrt.room.length,
                'v': mrt.room.height,
                'offset': {'x': mrt.room.width, 'y': 0, 'z': 0},
                'subsurfaces': [],
            },
            {
                'name': 'wall3', 
                'temperature': params['wall 3'].temperature,
                'emissivity': params['wall 3'].emissivity,
                'plane': 'xz', 
                'u': mrt.room.width,
                'v': mrt.room.height,
                'offset': {'x': 0, 'y': mrt.room.length, 'z': 0},
                'subsurfaces': [],
            },
            {
                'name': 'wall4', 
                'temperature': params['wall 4'].temperature,
                'emissivity': params['wall 4'].emissivity,
                'plane': 'yz', 
                'u': mrt.room.length,
                'v': mrt.room.height,
                'offset': {'x': 0, 'y': 0, 'z': 0},
                'subsurfaces': [],
            },
            {
                'name': 'ceiling', 
                'temperature': params['ceiling'].temperature,
                'emissivity': params['ceiling'].emissivity,
                'plane': 'xy', 
                'u': mrt.room.width,
                'v': mrt.room.length,
                'offset': {'x': 0, 'y': 0, 'z': mrt.room.height},
                'subsurfaces': [],
            },
            {
                'name': 'floor', 
                'temperature': params['ceiling'].temperature,
                'emissivity': params['ceiling'].emissivity,
                'plane': 'xy', 
                'u': mrt.room.width,
                'v': mrt.room.length,
                'offset': {'x': 0, 'y': 0, 'z': 0},
                'subsurfaces': [],
            }
        ];
      }

      function gen_zone_geometry(){
          var myZone = [
              { 'vertices': [{'x': 0, 'y': 0, 'z': 0},
                             {'x': 0, 'y': mrt.room.height, 'z': 0},
                             {'x': 0, 'y': mrt.room.height, 'z': mrt.room.length},
                             {'x': 0, 'y': 0, 'z': mrt.room.length}],
                /*'children': [
                  { 'vertices': [{'x': 0, 'y': mrt.room.height / 4, 'z': mrt.room.length / 4},
                                 {'x': 0, 'y': 3 * mrt.room.height / 4, 'z': mrt.room.length / 4},
                                 {'x': 0, 'y': 3 * mrt.room.height / 4, 'z': 3 * mrt.room.length / 4},
                                 {'x': 0, 'y': mrt.room.height / 4, 'z': 3 * mrt.room.length / 4}],
                    'radiant_t': 80.0,
                    'emissivity': 0.9,
                  },
                ],*/
              },
              { 'vertices': [{'x': 0, 'y': 0, 'z': 0},
                             {'x': mrt.room.width, 'y': 0, 'z': 0},
                             {'x': mrt.room.width, 'y': 0, 'z': mrt.room.length},
                             {'x': 0, 'y': 0, 'z': mrt.room.length}],
              },
              { 'vertices': [{'x': 0, 'y': 0, 'z': 0},
                             {'x': mrt.room.width, 'y': 0, 'z': 0},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': 0},
                             {'x': 0, 'y': mrt.room.height, 'z': 0}],
                //'children': [
                //  { 'vertices': [{'x': 20, 'y': 20, 'z': 0},
                //                 {'x': 40, 'y': 20, 'z': 0},
                //                 {'x': 40, 'y': 40, 'z': 0},
                //                 {'x': 30, 'y': 30, 'z': 0},
                //                 {'x': 20, 'y': 40, 'z': 0}],
                //    'radiant_t': 10.0,
                //    'emissivity': 0.9,
                //  },
                //  { 'vertices': [{'x': 60, 'y': 60, 'z': 0},
                //                 {'x': 80, 'y': 60, 'z': 0},
                //                 {'x': 80, 'y': 80, 'z': 0},
                //                 {'x': 70, 'y': 70, 'z': 0},
                //                 {'x': 60, 'y': 80, 'z': 0}],
                //    'radiant_t': 50.0,
                //    'emissivity': 0.9,
                //  },
                //],
              },
              { 'vertices': [{'x': mrt.room.width, 'y': 0, 'z': 0},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': 0},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': mrt.room.length},
                             {'x': mrt.room.width, 'y': 0, 'z': mrt.room.length}],
                /*'children': [
                  { 'vertices': [{'x': 100, 'y': 20, 'z': 20},
                                 {'x': 100, 'y': 30, 'z': 20},
                                 {'x': 100, 'y': 30, 'z': 30},
                                 {'x': 100, 'y': 40, 'z': 30},
                                 {'x': 100, 'y': 40, 'z': 40},
                                 {'x': 100, 'y': 50, 'z': 40},
                                 {'x': 100, 'y': 50, 'z': 20}],
                    'radiant_t': 30.0,
                    'emissivity': 0.9,
                  },
                ],*/
              },
              { 'vertices': [{'x': 0, 'y': mrt.room.height, 'z': 0},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': 0},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': mrt.room.length},
                             {'x': 0, 'y': mrt.room.height, 'z': mrt.room.length}],
                 //'children': [
                 //  { 'vertices': [{'x': 20, 'y': 100, 'z': 20},
                 //                 {'x': 80, 'y': 100, 'z': 20},
                 //                 {'x': 80, 'y': 100, 'z': 80},
                 //                 {'x': 50, 'y': 100, 'z': 50},
                 //                 {'x': 20, 'y': 100, 'z': 80}],
                 //    'radiant_t': 30.0,
                 //    'emissivity': 0.9,
                 //  },
                 //],
              },
              { 'vertices': [{'x': 0, 'y': 0, 'z': mrt.room.length},
                             {'x': mrt.room.width, 'y': 0, 'z': mrt.room.length},
                             {'x': mrt.room.width, 'y': mrt.room.height, 'z': mrt.room.length},
                             {'x': 0, 'y': mrt.room.height, 'z': mrt.room.length}],
              },
          ];
          return myZone;
      }

      function wallPanelGeometry(vertices){
        var Nv = vertices.length;
        var geometry = new THREE.Geometry();
        for (var j = 0; j < Nv; j++){
          geometry.vertices.push(new THREE.Vector3( vertices[j].x, vertices[j].y, vertices[j].z ))
        }
        for (var j = 0; j < Nv - 2; j++){
          var face = new THREE.Face3( 0, j+1, j+2 )
          geometry.faces.push(face);
        }
        return geometry;
      }
      
      function wallPanelMesh(geometry, texture){
        var material = new THREE.MeshPhongMaterial( { 
            color: 0xffffff, 
            map: texture, 
            bumpMap: texture, 
            reflectivity: 100, 
            transparent: true, 
            opacity: 1.0 
        } );
        material.side = THREE.DoubleSide;
        var uva = new THREE.Vector2(0,0);
        var uvb = new THREE.Vector2(0,1);
        var uvc = new THREE.Vector2(1,1);
        var uvd = new THREE.Vector2(1,0);

        geometry.faceVertexUvs[0].push([uva, uvb, uvc])
        geometry.faceVertexUvs[0].push([uva.clone(), uvc, uvd.clone()])
        geometry.computeFaceNormals();

        var mesh = new THREE.Mesh(geometry, material);
        return mesh;
      }

      function remove_zone() {
        var objsToRemove = _.rest(scene.children, 1);
        _.each(objsToRemove, function( object ) {
              scene.remove(object);
        });
      }

      function render_zone(){

        // Grid
        var size = _.max([mrt.room.lenth, mrt.room.width]) + 5;
        var step = 1; // size / 10;
        var geometry = new THREE.Geometry();
        for ( var i = 0; i <= mrt.room.length; i += step ) {
          geometry.vertices.push( new THREE.Vector3( 0, 0, i ) );
          geometry.vertices.push( new THREE.Vector3( mrt.room.width, 0, i ) );
        }
        for ( var i = 0; i <= mrt.room.width; i += step ) {
          geometry.vertices.push( new THREE.Vector3( i, 0, 0 ) );
          geometry.vertices.push( new THREE.Vector3( i, 0, mrt.room.length) );
        }

        var material = new THREE.LineBasicMaterial( { color: 0xaaaaaa, opacity: 0.2 } );
        var line = new THREE.Line( geometry, material );
        line.type = THREE.LinePieces;
        scene.add( line );

        var z = gen_zone_geometry();

        // plane has the same dimensions as the floor
        var margin = {
          'x': mrt.room.width / 20,
          'y': mrt.room.length / 20,
        }
        var aspect_ratio = mrt.room.width / mrt.room.height;
        var Nx = Math.floor(10 / aspect_ratio);
        var Ny = Math.floor(10 * aspect_ratio);

        var plane_geometry = new THREE.PlaneGeometry( mrt.room.width - margin.x, mrt.room.length - margin.y, Nx, Ny );

        var material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide,
          vertexColors: THREE.VertexColors,
        });

        plane = new THREE.Mesh( plane_geometry, material );
        plane.rotation.x = Math.PI / 2;
        plane.position.x = mrt.room.width / 2;
        plane.position.y = mrt.room.height / 2;
        plane.position.z = mrt.room.length / 2;
        plane.geometry.dynamic = true; // so that we can change the vertex colors
        plane.name = "visualization";
        scene.add( plane );

        var Np = z.length;
        var thetax, thetaz
        for (var i = 0; i < Np; i++){ 
          var p = z[i];
          var wall = wallPanelGeometry(p.vertices);
          var panel_texture = THREE.ImageUtils.loadTexture( 'img/wall.jpg' );

          if (p.hasOwnProperty('children')){

            wall.computeFaceNormals();
            var n0 = wall.faces[0].normal;
            var arg = Math.pow(n0.x, 2) + Math.pow(n0.z, 2)
            if (arg == 0){
              thetay = 0;
            } else {
              thetay = Math.acos( n0.z / arg );
            }
            
            arg = Math.pow(n0.y, 2) + Math.pow(n0.z, 2)
            if (arg == 0){
              thetax = 0;
            } else {
              thetax = Math.acos( n0.z / arg );
            }

            var t = new THREE.Matrix4();
            var u = new THREE.Matrix4();
            var ti = new THREE.Matrix4();
            t.makeRotationX(thetax);
            u.makeRotationY(thetay);
            t.multiply( u );
            ti.getInverse( t );

            // height translation to be applied later
            var h = new THREE.Matrix4();
            h.makeTranslation(0, wall.vertices[0].y, 0);

            wall.applyMatrix( t );
            var wallShape = new THREE.Shape();
            wallShape.moveTo( wall.vertices[0].x, wall.vertices[0].y );

            for (var j = 1; j < wall.vertices.length; j++){
              var v = wall.vertices[j];
              wallShape.lineTo( v.x, v.y );
            }

            for (var k = 0; k < p.children.length; k++){
              var panel = wallPanelGeometry(p.children[k].vertices);
              panel.applyMatrix( t );
              var hole = new THREE.Path();
              hole.moveTo(panel.vertices[0].x, panel.vertices[0].y);
              for (var kk = (panel.vertices.length - 1); kk > 0; kk--){
                hole.lineTo(panel.vertices[kk].x, panel.vertices[kk].y);
              }
              wallShape.holes.push(hole);

              panel.applyMatrix( ti );
              var mesh = wallPanelMesh(panel, panel_texture);
              scene.add(mesh);
              surfaces.push(mesh);

              // edges
              var egh = new THREE.EdgesHelper(mesh, 0x444444);
              egh.material.linewidth = 2;
              scene.add(egh);
            }
            wall = new THREE.ShapeGeometry(wallShape);
            wall.applyMatrix( ti );
            wall.applyMatrix( h );
          }

          // wall texture
          var wall_texture = THREE.ImageUtils.loadTexture( 'img/wall1.jpg' );
          var material = new THREE.MeshPhongMaterial( { 
              color: 0xffffff, 
              map: wall_texture, 
              bumpMap: wall_texture, 
              reflectivity: 100, 
              transparent: true, 
              opacity: 1.0,
          } );

          material.side = THREE.DoubleSide;
          var mesh = new THREE.Mesh(wall, material);

          var uva = new THREE.Vector2(0,0);
          var uvb = new THREE.Vector2(0,1);
          var uvc = new THREE.Vector2(1,1);
          var uvd = new THREE.Vector2(1,0);
          
          mesh.geometry.faceVertexUvs[0].push([uva, uvb, uvc])
          mesh.geometry.faceVertexUvs[0].push([uva.clone(), uvc, uvd.clone()])
          
          mesh.geometry.computeFaceNormals();
          mesh.geometry.computeVertexNormals();
          scene.add(mesh);
          surfaces.push(mesh);
          
          setOpacity(params.opacity);

          // edges
          var egh = new THREE.EdgesHelper(mesh, 0x444444);
          egh.material.linewidth = 2;
          scene.add(egh);

        }
      }

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.CombinedCamera( window.innerWidth / 2, window.innerHeight / 2, 70, 1, 3000, - 500, 1000 );
        camera.position.x = mrt.room.width * 2;
        camera.position.y = mrt.room.height * 2;
        camera.position.z = mrt.room.length * 2;
        scene = new THREE.Scene();
        raycaster = new THREE.Raycaster();
        projector = new THREE.Projector();

        // Gui
        var gui = new dat.GUI();

        var f_room = gui.addFolder('Room')
        f_room.add(mrt.room, 'width').min(2).max(100).step(1)
          .onFinishChange(function(){
            if (params.autocalculate){
              calculate_all();
            }
          });
        f_room.add(mrt.room, 'length').min(2).max(100).step(1)
          .onFinishChange(function(){
            if (params.autocalculate){
              calculate_all();
            }
          })
        f_room.add(mrt.room, 'height').min(2).max(16).step(0.1)
          .onFinishChange(function(){
            if (params.autocalculate){
              calculate_all();
            }
          });

        gui.add(mrt.occupant, 'posture', [ 'seated', 'standing' ] )
          .onFinishChange(function(){
            mrt_mesh();
          })

        function set_surface_property(surface_name, property, value){         
          var surface = _.find(mrt.walls, function(r){ return r.name == surface_name; });
          surface[property] = value;
          if (params.autocalculate){
            mrt_mesh();
          }
        }

        var f_wall1 = gui.addFolder('Wall 1');
        f_wall1.add(params['wall 1'], 'temperature').min(0).max(100).step(1)
          .onFinishChange(function(){ set_surface_property('wall1', 'temperature', params['wall 1'].temperature) });
        f_wall1.add(params['wall 1'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('wall1', 'emissivity', params['wall 1'].emissivity ) });

        var f_wall2 = gui.addFolder('Wall 2');
        f_wall2.add(params['wall 2'], 'temperature').min(0).max(100).step(0.1)
          .onFinishChange(function(){ set_surface_property('wall2', 'temperature', params['wall 2'].temperature) });
        f_wall2.add(params['wall 2'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('wall2', 'emissivity', params['wall 2'].emissivity) });

        var f_wall3 = gui.addFolder('Wall 3');
        f_wall3.add(params['wall 3'], 'temperature').min(0).max(100).step(0.1)
          .onFinishChange(function(){ set_surface_property('wall3', 'temperature', params['wall 3'].temperature) });
        f_wall3.add(params['wall 3'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('wall3', 'emissivity', params['wall 3'].emissivity) });

        var f_wall4 = gui.addFolder('Wall 4');
        f_wall4.add(params['wall 4'], 'temperature').min(0).max(100).step(0.1)
          .onFinishChange(function(){ set_surface_property('wall4', 'temperature', params['wall 4'].temperature) });
        f_wall4.add(params['wall 4'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('wall4', 'emissivity', params['wall 4'].emissivity) });

        var f_ceiling = gui.addFolder('Ceiling')
        f_ceiling.add(params['ceiling'], 'temperature').min(0).max(100).step(0.1)
          .onFinishChange(function(){ set_surface_property('ceiling', 'temperature', params['ceiling'].temperature) });
        f_ceiling.add(params['ceiling'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('ceiling', 'emissivity', params['ceiling'].emissivity) });

        var f_floor = gui.addFolder('Floor');
        f_floor.add(params['floor'], 'temperature').min(0).max(100).step(0.1)
          .onFinishChange(function(){ set_surface_property('floor', 'temperature', params['floor'].temperature) });
        f_floor.add(params['floor'], 'emissivity').min(0).max(1).step(0.01)
          .onFinishChange(function(){ set_surface_property('floor', 'emissivity', params['floor'].emissivity) });
    
        gui.add(params, 'opacity').min(0).max(100).step(1)
          .onFinishChange(function(){ setOpacity(params.opacity) });

        gui.add(params, 'autocalculate');
        gui.add(params, 'calculate now');

        // Lights
        var ambientLight = new THREE.AmbientLight( 0x999999 );
        scene.add( ambientLight );

        directionalLight = new THREE.DirectionalLight( 0x808080, 1.0 );
        directionalLight.position.set( 0, 1, 0 );
        scene.add( directionalLight );

        renderer = new THREE.WebGLRenderer( { antialiasing: true } );
        renderer.setClearColor( 0xf0f0f0 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        container.appendChild( renderer.domElement );
        
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'click', onDocumentClick, false );
        
        function onWindowResize(){
          camera.setSize( window.innerWidth, window.innerHeight );
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }

        set_wall_properties();
        render_zone();
        mrt_mesh();
      }

      function calculate_all(){
        remove_zone();
        set_wall_properties();
        render_zone();
        //mrt_mesh();
        setTimeout(mrt_mesh, 100);
      }

      function setOpacity(opacity){
        for (var i = 0; i < scene.children.length; i++){
          var ch = scene.children[i];
          if (ch.hasOwnProperty('material')){
            ch.material.opacity = opacity / 100;
          }
        }
      }

      function onDocumentClick( event ){
        if ( INTERSECTED ){
          console.log(INTERSECTED.uuid);
        }
      }

      function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      }

      function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
      }

      function render() {
        var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
        projector.unprojectVector( vector, camera );
        raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
        var intersects = raycaster.intersectObjects( surfaces );
        if ( intersects.length > 0 ) {
          if ( INTERSECTED != intersects[ 0 ].object) {
            if ( INTERSECTED ) {
              INTERSECTED.material.ambient.setHex( INTERSECTED.currentHex );
              INTERSECTED.material.transparent = true;
            }
            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.ambient.getHex();
            INTERSECTED.material.ambient.setHex( 0xffffa0 );
          }
        } else {
          if ( INTERSECTED ) INTERSECTED.material.ambient.setHex( INTERSECTED.currentHex );
          INTERSECTED = null;
        }
        
        directionalLight.position.copy( camera.position );
        directionalLight.position.normalize();
        renderer.render( scene, camera );
        controls.update();
           
      }

      function mrt_mesh(){
        var mrt_vertices = _.map(plane.geometry.vertices, function(v){ 
          var vec = v.clone()
          vec.applyMatrix4( plane.matrixWorld );
          mrt.occupant.position.x = vec.x;
          mrt.occupant.position.y = vec.z;
          return mrt.calc();
        });
        var mrt_min = _.min(mrt_vertices);
        var mrt_max = _.max(mrt_vertices);
        var mrt_colors = _.map(mrt_vertices, function(v_mrt){
          var r = (v_mrt - mrt_min) / (mrt_max - mrt_min);
          //return new THREE.Color(r, r, r);
          return new THREE.Color(1 - r, 0, r);
        });

        var faceIndices = [ 'a', 'b', 'c'];
        for (var i = 0; i < plane.geometry.faces.length; i++){
          var f = plane.geometry.faces[i];
          f.vertexColors = [];
          for (var j = 0; j < 3; j++){
            var idx = f[ faceIndices[ j ] ];
            f.vertexColors.push( mrt_colors[ idx ] );
          }
        }
        plane.geometry.colorsNeedUpdate = true;
      }

    </script>

  </body>
</html>
