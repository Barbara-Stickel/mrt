<!doctype html>
<html lang="en">
<head>
  <title>3d MRT calculator</title>
  <meta charset="utf-8">
</head>
<body style="margin: 0;">

  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/underscore.js"></script>
  
  <script>

    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer;

    init();
    animate();

    // Sets up the scene.
    function init() {

      // Create the scene and set the scene size.
      scene = new THREE.Scene();
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      // Create a renderer and add it to the DOM.
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(WIDTH, HEIGHT);
      document.body.appendChild(renderer.domElement);

      // Set the background color of the scene.
      renderer.setClearColor(0xdedede, 1);
      
      // Add shoebox model
      surfaces = {
        "floor": {"t": 23 },
        "ceiling": {"t": 18 },
        "north_wall": {"t": 30 },
        "south_wall": {"t": 20 },
        "east_wall": {"t": 10 },
        "west_wall": {"t": 0 }
      };
      window.shoebox_WIDTH = 30;
      window.shoebox_DEPTH = 20;
      window.shoebox_HEIGHT = 10;
      window.s = Shoebox(shoebox_WIDTH,shoebox_DEPTH,shoebox_HEIGHT,surfaces);

      for (var i = 0; i<s.length; i++){
        scene.add(s[i])
      }
      
      // Put a light in the shoebox
      var light = new THREE.PointLight(0xB3ECFF, 1.5, 100);
      light.position.set(shoebox_WIDTH/2, shoebox_DEPTH/2, shoebox_HEIGHT/2);
      scene.add(light);
      
      // Create a camera (want orthographic)
      //camera = new THREE.OrthographicCamera(-WIDTH/2, WIDTH/2, HEIGHT/2, HEIGHT/-2, 0.1, 20000);      
      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 40000);
      camera.position.set(5*shoebox_WIDTH, 5*shoebox_DEPTH, 5*shoebox_HEIGHT);
      scene.add(camera);

      // Create an event listener that resizes the renderer with the browser window.
      window.addEventListener('resize', function() {
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();
      });
      
      var arrow = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 50, 0x000000)
      scene.add(arrow);
      
      // Add OrbitControls so that we can pan around with the mouse.
      controls = new THREE.OrbitControls(camera, renderer.domElement);
    }
    
    // given a shoebox generated by fn Shoebox, what is the MRT
    // at point xyz (spherical mesh defined by dth)
    function MRT(x0, y0, z0, s) {
      var origin = new THREE.Vector3(x0, y0, z0);
      var dth = Math.PI / 10;
      var x, y, z;
      var origin = new THREE.Vector3(0,0,0)
      var direction = new THREE.Vector3(0, 0, 1);
      var rc = new THREE.Raycaster(origin, direction)
      
      // using the builtin sphere geometry face normals
      var sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 20, 20), new THREE.MeshNormalMaterial());
      var L = sphere.geometry.faces.length;
      var surfTs = new Array(L);
      for (var i = 0; i < L; i++){
        direction = sphere.geometry.faces[i].normal;
        rc.set(origin, direction);
        var collision = rc.intersectObjects(s);
        if (collision.length > 0){
          surfTs[i] = collision[0].object.t;
        //    var arrow = new THREE.ArrowHelper(direction, origin, 5, 0x00ff00);
        //} else {
        //    var arrow = new THREE.ArrowHelper(direction, origin, 5, 0xff0000);
        }
        //scene.add(arrow);
      }
      var myMRT = _.reduce(surfTs, function(memo, num){ return memo + num / L; }, 0);
      return myMRT;
      
      /*
      // ... versus parametrization of a sphere 
      var collisions = [];
      for (var th = 0; th < 2*Math.PI; th += dth){
        for (var phi = 0; phi < Math.PI; phi += dth){
          x = Math.sin(th) * Math.cos(phi);
          y = Math.sin(th) * Math.sin(phi);
          z = Math.cos(th);
          direction = new THREE.Vector3(x, y, z);
          rc.set(origin, direction);
          var collision = rc.intersectObjects(s);
          collisions.push(collision);
          //var arrow = new THREE.ArrowHelper(direction, origin, 10, 0xff0000);
          //scene.add(arrow)
        }
      }
      */
    }

    // returns an array of plane meshes for a shoebox
    // with width x, depth y, and height z
    function Shoebox(x, y, z, surfaces){

        var meshMaterial = new THREE.MeshLambertMaterial();        

        var ceilingGeo = new THREE.PlaneGeometry(x, y);
        var ceiling = new THREE.Mesh(ceilingGeo, meshMaterial);
        ceiling.rotation.x = -Math.PI;
        ceiling.position.z += z;
        ceiling.position.y += y/2;
        ceiling.position.x += x/2;
        ceiling.t = surfaces.ceiling.t;
        ceiling.name = "ceiling"
 
        var floorGeo = new THREE.PlaneGeometry(x, y);
        var floor = new THREE.Mesh(floorGeo, meshMaterial);
        floor.position.x += x/2;
        floor.position.y += y/2;
        floor.t = surfaces.floor.t;
        floor.name = "floor"

        var southGeo = new THREE.PlaneGeometry(x, z);
        var south = new THREE.Mesh(southGeo, meshMaterial);
        south.rotation.x = -Math.PI/2;
        south.position.z += z/2;
        south.position.x += x/2;
        south.t = surfaces.south_wall.t
        south.name = "south wall"

        var northGeo = new THREE.PlaneGeometry(x, z);
        var north = new THREE.Mesh(northGeo, meshMaterial);
        north.rotation.x = Math.PI/2;
        north.position.z += z/2;
        north.position.y += y;
        north.position.x += x/2;
        north.t = surfaces.north_wall.t;
        north.name = "north wall"
        
        var eastGeo = new THREE.PlaneGeometry(z, y);
        var east = new THREE.Mesh(eastGeo, meshMaterial);
        east.rotation.y = -Math.PI/2;
        east.position.z += z/2;
        east.position.y += y/2;
        east.position.x += x;
        east.t = surfaces.east_wall.t;
        east.name = "east wall"

        var westGeo = new THREE.PlaneGeometry(z, y);
        var west = new THREE.Mesh(westGeo, meshMaterial);
        west.rotation.y = Math.PI/2;
        west.position.z += z/2;
        west.position.y += y/2;
        west.t = surfaces.west_wall.t;
        west.name = "west wall"

        return [ceiling, floor, south, north, east, west];  
    }

    // Renders the scene and updates the render as needed.
    function animate() {
      // Read more about requestAnimationFrame at 
      // http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      requestAnimationFrame(animate);
      
      // Render the scene.
      renderer.render(scene, camera);
      controls.update();
    }
    
    function MRT_mesh(mesh_height){
      var start = new Date().getTime();
      var dx = 0.5;
      var dy = 0.5;
      var myMRT;
      var L = (shoebox_WIDTH / dx - 1) * (shoebox_DEPTH / dy - 1);
      var mesh = new Array(L);
      var i = 0;
      for (var x = dx; x < shoebox_WIDTH; x += dx){
        for (var y = dy; y< shoebox_DEPTH; y += dy){
          var myMRT = MRT(x, y, mesh_height, s)
          mesh[i] = {"x": x, "y": y, "MRT": myMRT};
          i++;
        }
      }
      var end = new Date().getTime();
      console.log("points: " + mesh.length + "\nexecution time: " + (end-start) + "ms" + "\navg time: " + (end-start)/mesh.length + "ms");
      return mesh;
    }

    function render_mesh(mesh){
      _.each(mesh, function(m){
        var sphere = new THREE.Mesh(new THREE.SphereGeometry(m.MRT/100, 10, 10), new THREE.MeshNormalMaterial());
        sphere.position.x = m.x;
        sphere.position.y = m.y;
        sphere.position.z = m.MRT/10;
        scene.add(sphere);
      });
    }
    
  </script>

</body>
</html>
